#!/bin/bash

git config core.fileMode false

if [[ -z "$1" ]] ; then
  echo "usage: $0 <branch> [--force | -f] [--no-migrate | -n] [--kill-modules | -ff ] [--no-compile] [-r <remote>] [--no-summary] [--develop | -d]"
  echo "-f forces the checkout, even if local changes are uncommitted"
  echo "--nomigrate will prevent database migrations running automatically after checkout"
  exit 1
fi

source /etc/openeyes/modules.conf
dir=$PWD
gitroot="openeyes"

defaultbranch=master


# Process commandline parameters
#  If -f was not specified on the command line, then check each module
#  to see if any changes are unstaged.
force=0
killmodules=0
migrate=1
fix=1
compile=1
customgitroot=0
nosummary=0
branch=$defaultbranch
for i in "$@"
do
case $i in
	-f|-force|--force) force=1
		## Force will ignore any uncomitted changes and checkout over the top
		;;
	-ff|--killmodules|--kill-modules) force=1; killmodules=1
		## killmodules should only be used when moving backwards from versions 1.12.1 or later to version 1.12 or earlier - removes the /protected/modules folder and re-clones all modules
		;;
	--develop|--d|-d) defaultbranch=develop
		## develop will use develop baranches when the named branch does not exist for a module (by default it would use master)
		;;
	--nomigrate|--no-migrate|--n|-n) migrate=0
		## nomigrate will prevent database migrations from running automatically at the end of checkout
		;;
	--root|-r|--r|--remote) customgitroot=1
		## Await custom root for git repo in next parameter
		;;
	--no-summary) nosummary=1
		## don't show summary of checkout at completion
		;;
	--no-fix) fix=0
		## don't run oe-fix at completion
		;;
	--no-compile) compile=0
		## don't compile java
		;;
	*)  if [ ! -z "$i" ]; then
			if [ "$customgitroot" = "1" ]; then
				gitroot=$i;
				customgitroot=0
				## Set root path to repo
			elif [ "$branch" == "master" ]; then
				branch=$i
			else echo "Unknown command line: $i"
				## Set branch name
			fi
		fi
    ;;
esac
done

echo "Checking out $branch..."

if [ ! "$force" = "1" ]; then
	echo "checking for uncommited changes"

	  changes=0
	  modulelist=""

	  # Check openeyes core
	  cd /var/www/openeyes
	  git diff --quiet
	  if [ ! $? = 0 ]; then
		  changes=1
		  modulelist="$modulelist openeyes"
	  fi

	  # ensure modules directory exists - prevents code being checked out to wrong place
	  mkdir -p /var/www/openeyes/protected/modules
	  cd /var/www/openeyes/protected/modules
	  for module in ${modules[@]}; do
		if [ ! -d "$module" ]; then
			if [ ! "$module" = "openeyes" ]; then printf "\e[31mModule $module not found\e[0m\n"; fi
		else
			if [ ! "$module" = "openeyes" ]; then cd $module; fi

			# check if this is a git repo
			if [ -d ".git" ]; then
					git diff --quiet
					if [ ! $? = 0 ]; then
					  changes=1
					  modulelist="$modulelist $module"
					fi
			fi
		fi

		if [ ! "$module" = "openeyes" ]; then cd ..; fi
	  done

	  cd  /var/www/openeyes/protected/javamodules/
	  for module in ${javamodules[@]}; do
		if [ ! -d "$module" ]; then
			printf "\e[31mModule $module not found\e[0m\n"
		else
			cd $module;
			git diff --quiet
			if [ ! $? = 0 ]; then
			  changes=1
			  modulelist="$modulelist $module"
			fi
			cd ..
		fi
	  done

	  #  If we have unstaged changes, then abort and  warn which modules are affected
	  if [ "$changes" = "1" ]; then
		printf "\e[41m\e[97m  CHECKOUT ABORTED  \e[0m \n"
		echo "There are uncommitted changes in the following modules: $modulelist"
		printf "To ignore these changes, run: \e[1m $0 $branch -f \e[0m \n"
		echo "Alternatively, manually git reset --hard to ignore, or git stash to keep, etc"
		printf "\e[41m\e[97m  CHECKOUT ABORTED  \e[0m \n";
		echo ""
		exit 1
	  fi
	#fi
fi

# If -ff was speified, kill all existing modules and re-clone
if [ $killmodules = 1 ]; then rm -rf /var/www/openeyes/protected/modules; fi

# check out openeyes core
mkdir -p /var/www/openeyes
cd /var/www/openeyes

if [ ! -d ".git " ]; then
	printf "\e[32mopeneyes: Doesn't currently exist - cloning: \e[0m"
	# checkout branch. If branch doesn't exist then get default instead
	if ! git clone -b $branch https://github.com/$gitroot/openeyes ./ ; then
		echo "$branch doesn't exist. Falling back to $defaultbranch branch for openeyes..."
		if ! git clone -b $defaultbranch https://github.com/$gitroot/openeyes ./ ; then
			# If we cannot find default branch at specifeid remote, fall back to OE git hub
			if [ "$gitroot != "openeyes ]; then
				echo "could not find $defaultbranch at $gitroot remote. Falling back to openeyes official repo"
				git clone -b $defaultbranch https://github.com/openeyes/openeyes ./
			fi
		fi
	fi
else
	printf "\e[32mopeneyes: \e[0m"

	git reset --hard
	git fetch --all

	git checkout tags/$branch 2>/dev/null
	if [ ! $? = 0 ]; then git checkout $branch 2>/dev/null; fi
	if [ ! $? = 0 ]; then echo "no branch $branch exists, switching to $defaultbranch"; git checkout $defaultbranch 2>/dev/null; fi
fi

# Check out the PHP modules
mkdir -p /var/www/openeyes/protected/modules
cd /var/www/openeyes/protected/modules

for module in ${modules[@]}; do
  if [ ! -d "$module" ]; then
		if [ ! "$module" = "openeyes" ]; then
			printf "\e[32m$module: Doesn't currently exist - cloning: \e[0m"

			# checkout branch. If branch doesn't exist then get master instead
			if ! git clone -b $branch https://github.com/$gitroot/$module; then
				echo "falling back to $defaultbranch branch for $module..."
				if ! git clone -b $defaultbranch https://github.com/$gitroot/$module ; then
					# If we cannot find default branch at specifeid remote, fall back to OE git hub
					if [ "$gitroot != "openeyes ]; then
						echo "could not find $defaultbranch at $gitroot remote. Falling back to openeyes official repo"
						git clone -b $defaultbranch https://github.com/openeyes/$module./
					fi
				fi
			fi
		fi
  else
    cd $module

	# Check if this is a git repo
    if [ -d ".git" ]; then
		printf "\e[32m$module: \e[0m"
		git reset --hard
		git fetch --all
		git checkout tags/$branch 2>/dev/null
		if [ ! $? = 0 ]; then git checkout $branch 2>/dev/null; fi
		if [ ! $? = 0 ]; then echo "no branch $branch exists, switching to $defaultbranch"; git checkout $defaultbranch 2>/dev/null; fi
	fi
    cd ..
  fi
done

# Check out the Java modules
mkdir -p /var/www/openeyes/protected/javamodules
cd /var/www/openeyes/protected/javamodules
for module in ${javamodules[@]}; do
  if [ ! -d "$module" ]; then
    printf "\e[32m$module: Doesn't currently exist - cloning: \e[0m"
	# checkout branch. If branch doesn't exist then get master instead
			if ! git clone -b $branch https://github.com/$gitroot/$module; then
				echo "falling back to $defaultbranch branch for $module..."
				git clone -b $defaultbranch https://github.com/$gitroot/$module
			fi
  else
    cd $module
    git reset --hard
    git fetch --all
    git checkout tags/$branch 2>/dev/null
    if [ ! $? = 0 ]; then git checkout $branch 2>/dev/null; fi
	if [ ! $? = 0 ]; then echo "no branch $branch exists, switching to $defaultbranch"; git checkout $defaultbranch 2>/dev/null; fi
    cd ..
  fi
done

# Compile IOLImporter
##TODO: When we have more java modules, replace with a generic compilation model
if [ $compile = 1 ]; then
  echo "
  Compiling IOLMAsterImport. Please wait....
  "

  cd IOLMasterImport
  ./compile.sh
  if [ ! $? = 0 ]; then echo "Failure is expeced in pre v1.12 releases (where IOLMasterImport does not exist)"; fi
fi

# symlink lib for IOLMasterImport
##TODO:  When we have more java modules, replace with a generic compilation model
ln -s ./lib ./dist/lib
if [ ! $? = 0 ]; then echo "Failure is expeced in pre v1.12 releases (where IOLMasterImport does not exist)"; fi


# Now reset/relink various config files etc
if [ "$fix" = "1" ]; then  oe-fix; fi

cd "$dir"


# Automatically migrate up, unless --nomigrate parameter is given
if [ "$migrate" = "1" ]; then
	oe-migrate
else
	echo "
Migrations were not run automaically. If you need to run the database migrations, run command oe-migrate
"
fi

# Show summary of checkout
if [ ! "$nosummary" = "1" ]; then
	oe-which
	printf "\e[42m\e[97m  CHECKOUT COMPLETE  \e[0m \n"
fi

echo ""
